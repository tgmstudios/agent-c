const express = require('express');
const router = express.Router();
const { GoogleGenerativeAI } = require("@google/generative-ai");
const fs = require('fs').promises; // Use promises for asynchronous file reading
const db = require('../lib/db.js');
const multer = require('multer');
const pdfParse = require('pdf-parse');
const { responseSchema } = require('../ai_src/path-schema.js'); 
const { prompt } = require('../ai_src/path-prompt.js'); 

// Access your API key as an environment variable
const genAI = new GoogleGenerativeAI(process.env.GEMINI_API_KEY);

// Configure Multer for file storage
const storage = multer.memoryStorage(); // Store file in memory as a buffer
const upload = multer({ storage: storage });

async function convertPdfToText(fileBuffer) {
  try {
    const data = await pdfParse(fileBuffer);
    return data.text;
  } catch (error) {
    console.error("Error converting PDF to text:", error);
    throw new Error("Failed to convert PDF to text");
  }
}

async function generatePrompt(sessionId) {
  try {
    // Fetch user data
    const user = await db.search('users', 'session_id', sessionId);
    const preferences = await db.search('preferences', 'session_id', sessionId);
    const transcript = await db.search('transcripts', 'session_id', sessionId);

    let transcriptText = '';
    if (transcript && transcript.file) {
      try {
        // Convert the transcript PDF to text
        transcriptText = await convertPdfToText(transcript.file);
        transcriptText = `Transcript: ${transcriptText}`; // Add label
      } catch (error) {
        console.error("Error processing transcript:", error);
        transcriptText = 'Error processing transcript';
      }
    }

    // Combine user data into a single string
    const userData = `
      User Name: ${user ? user.name : 'N/A'}
      Preferences: ${preferences ? JSON.stringify(preferences) : 'N/A'}
      ${transcriptText}
    `;

    // Combine base prompt with user data
    const fullPrompt = `${prompt}\n\nUser Information:\n${userData}`;
    return fullPrompt;

  } catch (error) {
    console.error("Error generating prompt:", error);
    throw new Error("Failed to generate prompt");
  }
}

async function generateRecommendation(sessionId) {
  const model = genAI.getGenerativeModel({ 
    model: "gemini-2.0-flash",
    generationConfig: {
      temperature: 0.7,
      topP: 0.9,
      topK: 40,
      maxOutputTokens: 8192 // Request maximum token length
    }
   });

  try {
    const prompt = await generatePrompt(sessionId);
    
    console.log("Prompt sent to Gemini:", prompt); // Log the prompt

    // Generate content with structured output configuration
    const result = await model.generateContent({
      contents: [{ role: "user", parts: [{ text: prompt }] }],
      generationConfig: {
        responseMimeType: "application/json",
        responseSchema: responseSchema
      }
    });

    const response = await result.response;
    const text = response.text();
    
    // The response should already be valid JSON, but we'll parse it to be safe
    let structuredOutput = null;
    try {
      structuredOutput = JSON.parse(text);
      console.log("Parsed structured output:", structuredOutput); // Log the structured output
    } catch (parseError) {
      console.warn("Failed to parse response as JSON. Returning raw text.", parseError);
      structuredOutput = { rawText: text }; // Store raw text if parsing fails
    }

    return structuredOutput;
  } catch (error) {
    console.error("Error generating recommendation:", error);
    throw error; // Re-throw for the route handler to catch
  }
}

/**
 * @swagger
 * /path:
 *   get:
 *     summary: Retrieve a recommended 4-year college path using the Gemini API
 *     tags: [College Path]
 *     parameters:
 *       - in: header
 *         name: session-id
 *         required: true
 *         schema:
 *           type: string
 *         description: Session ID for authentication
 *     responses:
 *       200:
 *         description: A recommended 4-year college path
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 recommendation:
 *                   type: string
 *                   description: A 4-year college path as generated by the Gemini API
 *       500:
 *         description: Internal server error
 */
router.get('/', async (req, res) => {
  try {
    const sessionId = req.header('session-id');

    if (!sessionId) {
      return res.status(401).json({ error: 'Unauthorized: Missing session ID' });
    }

    const recommendation = await generateRecommendation(sessionId);
    res.status(200).json({ recommendation: recommendation });

  } catch (error) {
    console.error("Error generating recommendation:", error);
    res.status(500).json({ error: 'Failed to generate recommendation', details: error.message });
  }
});

module.exports = router;
