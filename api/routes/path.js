const express = require('express');
const router = express.Router();
const { GoogleGenerativeAI } = require("@google/generative-ai");
const fs = require('fs').promises; // Use promises for asynchronous file reading
const db = require('../lib/db.js');
const multer = require('multer');
const pdfParse = require('pdf-parse');

// Access your API key as an environment variable
const genAI = new GoogleGenerativeAI(process.env.GEMINI_API_KEY);

// Configure Multer for file storage
const storage = multer.memoryStorage(); // Store file in memory as a buffer
const upload = multer({ storage: storage });

async function convertPdfToText(fileBuffer) {
  try {
    const data = await pdfParse(fileBuffer);
    return data.text;
  } catch (error) {
    console.error("Error converting PDF to text:", error);
    throw new Error("Failed to convert PDF to text");
  }
}

async function generatePrompt(sessionId) {
  try {
    // Read the prompt from the prompt.txt file
    const basePrompt = await fs.readFile('./ai_src/prompt.txt', 'utf8');

    // Fetch user data
    const user = await db.search('users', 'session_id', sessionId);
    const preferences = await db.search('preferences', 'session_id', sessionId);
    const transcript = await db.search('transcripts', 'session_id', sessionId);

    let transcriptText = '';
    if (transcript && transcript.file) {
      try {
        // Convert the transcript PDF to text
        transcriptText = await convertPdfToText(transcript.file);
        transcriptText = `Transcript: ${transcriptText}`; // Add label
      } catch (error) {
        console.error("Error processing transcript:", error);
        transcriptText = 'Error processing transcript';
      }
    }

    // Combine user data into a single string
    const userData = `
      User Name: ${user ? user.name : 'N/A'}
      Preferences: ${preferences ? JSON.stringify(preferences) : 'N/A'}
      ${transcriptText}
    `;

    // Combine base prompt with user data
    const fullPrompt = `${basePrompt}\n\nUser Information:\n${userData}`;
    return fullPrompt;

  } catch (error) {
    console.error("Error generating prompt:", error);
    throw new Error("Failed to generate prompt");
  }
}

async function generateRecommendation(sessionId) {
  const model = genAI.getGenerativeModel({ model: "gemini-2.0-flash" }); // Or "gemini-2.0-flash"

  try {
    const prompt = await generatePrompt(sessionId);
    const fullPrompt = `${prompt}\n\nRespond with a JSON object that conforms to the schema:\n\`\`\`json\n{\n  \"major\": {\n    \"type\": \"string\",\n    \"description\": \"The recommended college major.\"\n  },\n  \"suggested_courses\": {\n    \"type\": \"array\",\n    \"description\": \"A list of suggested courses for the first year.\",\n    \"items\": {\n      \"type\": \"string\"\n    }\n  },\n  \"extracurricular_activities\": {\n    \"type\": \"array\",\n    \"description\": \"A list of suggested extracurricular activities.\",\n    \"items\": {\n      \"type\": \"string\"\n    }\n  }\n}\n\`\`\`\nEnsure the response is valid JSON.`;

    console.log("Prompt sent to Gemini:", fullPrompt); // Log the prompt

    const result = await model.generateContent(fullPrompt);
    const response = await result.response;
    const text = response.text();

    // Attempt to parse the response as JSON
    let structuredOutput = null;
    try {
      structuredOutput = JSON.parse(text);
      console.log("Parsed structured output:", structuredOutput); // Log the structured output
    } catch (parseError) {
      console.warn("Failed to parse response as JSON. Returning raw text.", parseError);
      structuredOutput = { rawText: text }; // Store raw text if parsing fails
    }

    return structuredOutput;
  } catch (error) {
    console.error("Error generating recommendation:", error);
    throw error; // Re-throw for the route handler to catch
  }
}

/**
 * @swagger
 * /path:
 *   get:
 *     summary: Retrieve a recommended 4-year college path using the Gemini API
 *     tags: [College Path]
 *     parameters:
 *       - in: header
 *         name: session-id
 *         required: true
 *         schema:
 *           type: string
 *         description: Session ID for authentication
 *     responses:
 *       200:
 *         description: A recommended 4-year college path
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 recommendation:
 *                   type: string
 *                   description: A 4-year college path as generated by the Gemini API
 *       500:
 *         description: Internal server error
 */
router.get('/', async (req, res) => {
  try {
    const sessionId = req.header('session-id');

    if (!sessionId) {
      return res.status(401).json({ error: 'Unauthorized: Missing session ID' });
    }

    const recommendation = await generateRecommendation(sessionId);
    res.status(200).json({ recommendation: recommendation });

  } catch (error) {
    console.error("Error generating recommendation:", error);
    res.status(500).json({ error: 'Failed to generate recommendation', details: error.message });
  }
});

module.exports = router;
